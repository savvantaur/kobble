/*also: * offset for snipped audio* javascript retrieval of in and out* pointer and scrubber with bobble* dark undercolour to mark download progress on slider* bright undercolour to show selected passage on slider* call pause at end of track? stop interval timer, anyway.*/// if in and out parameters supplied, fill in inat and outat and call displayinout// also set pause value to in figure, and move playhead to that position// scrub playhead to move pause position// playback while scrubbing?// check external javascript interface to snipperimport flash.external.ExternalInterfacestop();playpause_mc.gotoAndStop(1);mysound = new Sound(this);volume_level = 100;pause_position = 0;current_position = 0;display_timer = null;playback_ready = false;cliplength = 0;slidermin = 20;slidermax = 258;playondrop = false;inat = mp3in ? mp3in * 1000 : 0;outat = mp3out ? mp3out * 1000 : 0;function clearDisplay(){  greenleft_mc._visible = false;  greenbar_mc._visible = false;  greenright_mc._visible = false;  orangeleft_mc._visible = false;  orangebar_mc._visible = false;  orangeright_mc._visible = false;  inmarker_mc._visible = false;  outmarker_mc._visible = false;}function loadAudio(){  if (!mp3url) mp3url = "music/hurt.mp3";	mysound.loadSound(mp3url, true);	if (inat) pause_position = inat;  _stop();  playback_ready = true;  displayInOut();  playbackDisplay();	download_timer = setInterval(downloadDisplay, 1000);}function noAudio(success:Boolean) {  if (success == false) {    displayInOut();    playback_ready = false;    nowat_txt.text = 'file not found';  }}function downloadDisplay() {  got = mysound.getBytesLoaded();  of = mysound.getBytesTotal();  if (got > 0) {    greenleft_mc._visible = true;    greenbar_mc._visible = true;  }  greenbar_mc._width = as_pixels(got, of);  if (got >= of) {    greenright_mc._visible = true;    clearInterval(download_timer);  }}function playbackDisplay() {  pos = (is_playing()) ? mysound.position : pause_position;  trace('playbackDisplay: pos is ' + pos + ' and total is ' + cliplength)  nowat_txt.text = as_timecode(pos);  moveHead(pos);}function toggleAudio() {  if (! playback_ready)     return false;  if (is_playing()) { 	  pause_position = mysound.position;   _stop();  } else {    _start();  }};function _start(){	playAudioFrom(pause_position);	playback_timer = setInterval(playbackDisplay, 100);  playpause_mc.gotoAndStop(2)  }function _stop(){	mysound.stop();	if (playback_timer) clearInterval(playback_timer);	playbackDisplay();  playpause_mc.gotoAndStop(1)}function playAudioFrom(startpoint:Number){	mysound.stop();	mysound.start(int( (startpoint)/1000), 1 );}function setIn(){  inat = at_now();  inat_txt.textColor = 0xCC6E1F;  if (outat < inat) clearOut();  displayInOut();  in_mc.gotoAndStop(2)}function setOut(){  outat = at_now();  outat_txt.textColor = 0xCC6E1F;  if (inat > outat) clearIn();  displayInOut();  out_mc.gotoAndStop(2)}function displayInOut(){  inat_txt.text = as_timecode(inat);  outat_txt.text = as_timecode(outat);  orangebar_mc._visible = true;  if (inat == 0 && (outat == 0 || outat == cliplength)) {    orangebar_mc._visible = false;    orangeright_mc._visible = false;    orangeleft_mc._visible = false;    inmarker_mc._visible = false;    outmarker_mc._visible = false;      } else {    orangebar_mc._visible = true;    if (inat == 0) {      orangebar_mc._x = slidermin;      orangeleft_mc._visible = true;      inmarker_mc._visible = false;    } else {      orangebar_mc._x = slidermin + as_pixels(inat);      inmarker_mc._x = orangebar_mc._x;      orangeleft_mc._visible = false;      inmarker_mc._visible = true;    }    if (outat == cliplength) {      orangebar_mc._width = slidermax - orangebar_mc._x;      orangeright_mc._visible = true;      outmarker_mc._visible = false;    } else {      orangebar_mc._width = as_pixels(outat - inat);      outmarker_mc._x = orangebar_mc._x + orangebar_mc._width;      orangeright_mc._visible = false;      outmarker_mc._visible = true;    }  }}function clearInOut(){  clearIn();  clearOut();  displayInOut();}function clearIn(){  inat = 0;  inat_txt.textColor = 0x999999;  in_mc.gotoAndStop(1)}function clearOut(){  outat = cliplength;  outat_txt.textColor = 0x999999;  out_mc.gotoAndStop(1)}function at_now() {  pos = (is_playing()) ? mysound.position : pause_position;  return pos;}function moveHead(to:Number) {  newx = slidermin + as_pixels(to, cliplength, -8); // -8 is offset to allow for width of bobble  if (newx > slidermax) newx = slidermax;  if (newx < slidermin) newx = slidermin;  if (slider_mc._x != newx) slider_mc._x = newx;}function dragSlider(){  if (is_playing()) {    _stop();    playondrop = true;  } else {    playondrop = false;  }  slider_mc.startDrag(false, slidermin, slider_mc._y, slidermax, slider_mc._y );  }function dropSlider(){  slider_mc.stopDrag();  trace('drag stopped at ' + slider_mc._x);  pause_position = as_ms(slider_mc._x + 7 - slidermin);  nowat_txt.text = as_timecode(pause_position);  if (playondrop)    _start();}//formats a timecode in quicktime standard hh:mm:ss.sfunction as_timecode(time:Number){  if (time <= 0) return "00:00:00.0";  hours = Math.floor(time / 3600000);  if (hours < 10) hours = "0" + hours;  minutes = Math.floor((time % 3600000) / 60000);  if (minutes < 10) minutes = "0" + minutes;  seconds = Math.floor((time % 60000) / 1000);  if (seconds < 10) seconds = "0" + seconds;  tenths = Math.floor((time % 1000) / 100);  return hours + ':' + minutes + ':' + seconds + '.' + tenths;}// turns a timecode into an offset in number of pixels. this figure is normally// added to slidermin to set the position of the slider bobble or an in or out markerfunction as_pixels(sofar:Number, total:Number, offset:Number){  total = total || cliplength;  offset = offset || 0;  return Math.round((slidermax + offset - slidermin) * sofar / total);}// turns a pixel position back into milliseconds// used when bobble-drag ends, to move to the right part of the trackfunction as_ms( pos:Number, total:Number ){  total = total || slidermax - slidermin;  return Math.round(cliplength * (pos / total));}function is_playing(){  if (playpause_mc._currentframe == 1) return false;  return true;}playpause_mc.playpause_btn.onRelease = toggleAudio;in_mc.in_btn.onRelease = setIn;out_mc.out_btn.onRelease = setOut;clear_btn.onRelease = clearInOut;slider_mc.onPress = dragSlider;slider_mc.onRelease = slider_mc.onReleaseOutside = dropSlider;if (ExternalInterface.available) {	ExternalInterface.addCallback("playerOk", null, jsAvailable);	ExternalInterface.addCallback("loadFile", null, jsLoadFile);	ExternalInterface.addCallback("playerOut", null, jsOut);	ExternalInterface.addCallback("playerIn", null, jsIn);}function jsAvailable() {  return playback_ready;}function jsIn() {  if (is_playing()) _stop();  return as_timecode(inat);}function jsOut() {  if (is_playing()) _stop();  return as_timecode(outat);}function jsLoadFile() {  }clearDisplay();loadAudio();