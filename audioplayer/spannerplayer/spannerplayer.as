/*also: * offset for snipped audio* javascript retrieval of in and out* pointer and scrubber with bobble* dark undercolour to mark download progress on slider* bright undercolour to show selected passage on slider* call pause at end of track? stop interval timer, anyway.*/import flash.external.ExternalInterfacestop();playpause_mc.gotoAndStop(1);mysound = new Sound(this);volume_level = 100;pause_position = 0;current_position = 0;display_timer = null;playback_ready = false;cliplength = 0;slidermin = 20;slidermax = 258;playondrop = false;trackclicklimit = 0;inat = mp3in ? mp3in * 1000 : 0;outat = mp3out ? mp3out * 1000 : 0;function clearDisplay(){  greenleft_mc._visible = false;  greenbar_mc._visible = false;  greenright_mc._visible = false;  orangeleft_mc._visible = false;  orangebar_mc._visible = false;  orangeright_mc._visible = false;  inmarker_mc._visible = false;  outmarker_mc._visible = false;}function loadAudio(file:String){  mysound.onLoad = downloadComplete;	mysound.loadSound(file, true);  mysound.stop();	download_timer = setInterval(downloadProgress, 1000);}function gotAudio(){  mysound.stop();  playback_ready = true;  nowat_txt.text = as_timecode(0);	if (inat) pause_position = inat;  showSelection();}function downloadComplete(success:Boolean) {  if (success == false) {    showSelection();    playback_ready = false;    nowat_txt.text = 'file not found';  }}function downloadProgress() {  got = mysound.getBytesLoaded();  of = mysound.getBytesTotal();  if (! got || ! of || got == 0)    return;      if (!playback_ready)    gotAudio();  cliplength = mysound.duration;  trace('cliplength is ' + cliplength);  greenleft_mc._visible = true;  greenbar_mc._visible = true;  trackclicklimit = as_pixels(got, of);  greenbar_mc._width = trackclicklimit;  if (got >= of) {    greenright_mc._visible = true;    clearInterval(download_timer);  }}function playbackProgress() {  pos = (is_playing()) ? mysound.position : pause_position;  nowat_txt.text = as_timecode(pos);  moveHead(pos);}function showSelection(){  inat_txt.text = as_timecode(inat);  outat_txt.text = as_timecode(outat);  orangebar_mc._visible = true;  if (inat == 0 && (outat == 0 || outat == cliplength)) {    orangebar_mc._visible = false;    orangeright_mc._visible = false;    orangeleft_mc._visible = false;    inmarker_mc._visible = false;    outmarker_mc._visible = false;      } else {    orangebar_mc._visible = true;    if (inat == 0) {      orangebar_mc._x = slidermin;      orangeleft_mc._visible = true;      inmarker_mc._visible = false;    } else {      orangebar_mc._x = slidermin + as_pixels(inat);      inmarker_mc._x = orangebar_mc._x;      orangeleft_mc._visible = false;      inmarker_mc._visible = true;    }    if (outat == cliplength) {      orangebar_mc._width = slidermax - orangebar_mc._x;      orangeright_mc._visible = true;      outmarker_mc._visible = false;    } else {      orangebar_mc._width = as_pixels(outat - inat);      outmarker_mc._x = orangebar_mc._x + orangebar_mc._width;      orangeright_mc._visible = false;      outmarker_mc._visible = true;    }  }}function toggleAudio() {  if (! playback_ready)     return false;  if (is_playing()) { 	  pause_position = mysound.position;   _stop();  } else {    _start();  }};function _start(){	playAudioFrom(pause_position);	playback_timer = setInterval(playbackProgress, 100);  playpause_mc.gotoAndStop(2)  }function _stop(){	mysound.stop();	if (playback_timer) clearInterval(playback_timer);	playbackProgress();  playpause_mc.gotoAndStop(1)}function playAudioFrom(startpoint:Number){	mysound.stop();	mysound.start(int( (startpoint)/1000), 1 );}function setIn(){  inat = at_now();  inat_txt.textColor = 0xCC6E1F;  if (outat < inat) clearOut();  showSelection();  in_mc.gotoAndStop(2)}function setOut(){  outat = at_now();  outat_txt.textColor = 0xCC6E1F;  if (inat > outat) clearIn();  showSelection();  out_mc.gotoAndStop(2)}function clearInOut(){  clearIn();  clearOut();  showSelection();}function clearIn(){  inat = 0;  inat_txt.textColor = 0x999999;  in_mc.gotoAndStop(1)}function clearOut(){  outat = cliplength;  outat_txt.textColor = 0x999999;  out_mc.gotoAndStop(1)}function at_now() {  return (is_playing()) ? mysound.position : pause_position;}function moveHead(to:Number) {  newx = slidermin + as_pixels(to, cliplength, -10); // offset to allow for width of bobble  if (newx > slidermax) newx = slidermax;  if (newx < slidermin) newx = slidermin;  if (slider_mc._x != newx) slider_mc._x = newx;}function dragSlider(){  if (is_playing()) {    _stop();    playondrop = true;  } else {    playondrop = false;  }  slider_mc.startDrag(false, slidermin, slider_mc._y, slidermax, slider_mc._y );  }function dropSlider(){  slider_mc.stopDrag();  trace('drag stopped at ' + slider_mc._x);  pause_position = as_ms(slider_mc._x + 7 - slidermin);  trace('which gives us ' + pause_position + 's out of ' + cliplength);  nowat_txt.text = as_timecode(pause_position);  if (playondrop)    _start();}function clickSlider(){  if (is_playing()){    playondrop = true;    _stop();  } else {    playondrop = false;  }  x = _root._xmouse - slidermin;  trace('bar clicked at ' + x);    if (x < trackclicklimit) {    pause_position = as_ms(x + 7);    trace('which gives us ' + pause_position + 's out of ' + cliplength);    nowat_txt.text = as_timecode(pause_position);    moveHead(pause_position);    if (playondrop)      _start();  }}//formats a timecode in quicktime standard hh:mm:ss.sfunction as_timecode(time:Number){  if (time <= 0) return "00:00:00.0";  hours = Math.floor(time / 3600000);  if (hours < 10) hours = "0" + hours;  minutes = Math.floor((time % 3600000) / 60000);  if (minutes < 10) minutes = "0" + minutes;  seconds = Math.floor((time % 60000) / 1000);  if (seconds < 10) seconds = "0" + seconds;  tenths = Math.floor((time % 1000) / 100);  return hours + ':' + minutes + ':' + seconds + '.' + tenths;}// turns a timecode into an offset in number of pixels. this figure is normally// added to slidermin to set the position of the slider bobble or an in or out markerfunction as_pixels(sofar:Number, total:Number, offset:Number){  total = total || cliplength;  offset = offset || 0;  trace('as_pixels ' + sofar + ' / ' + total + ' (+ ' + offset + ')');  return Math.round((slidermax + offset - slidermin) * sofar / total);}// turns a pixel position back into milliseconds// used when bobble-drag ends, to move to the right part of the trackfunction as_ms( pos:Number, total:Number ){  total = total || slidermax - slidermin;  return Math.round(cliplength * (pos / total));}function is_playing(){  if (playpause_mc._currentframe == 1) return false;  return true;}playpause_mc.playpause_btn.onRelease = toggleAudio;in_mc.in_btn.onRelease = setIn;out_mc.out_btn.onRelease = setOut;clear_btn.onRelease = clearInOut;slider_mc.onPress = dragSlider;slider_mc.onRelease = slider_mc.onReleaseOutside = dropSlider;progress_btn.onRelease = clickSlider;if (ExternalInterface.available) {	ExternalInterface.addCallback("playerOk", null, jsAvailable);	ExternalInterface.addCallback("loadFile", null, jsLoadFile);	ExternalInterface.addCallback("playerOut", null, jsOut);	ExternalInterface.addCallback("playerIn", null, jsIn);}function jsAvailable() {  return playback_ready;}function jsIn() {  if (is_playing()) _stop();  return as_timecode(inat);}function jsOut() {  if (is_playing()) _stop();  return as_timecode(outat);}function jsLoadFile() {  }if (!mp3url) mp3url = "http://www.spanner.org/test/longtest.mp3";clearDisplay();loadAudio(mp3url);